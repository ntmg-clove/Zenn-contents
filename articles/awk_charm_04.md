---
title: "awkの魅力を伝える: 「ログの調査」"
emoji: "✨"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["awk", "Linuxコマンド", "ログ調査"]
published: false
---

# はじめに

## サンプルログ

# 実践例8. 抽出/整形 grep/sedの代用
正直書くのを悩みました．awkである必要は別にないと思ったため．
抽出であれば、`grep -o`や`sed`による後方参照を利用した置換コマンドを用いた方がスマートかと思います。
ただ、フィールドの定義が複雑な場合は区切り文字に正規表現を使用できるawkが優秀な場面が出てくるかと思います。grep/sedは正規表現に慣れていないと狙い通りに抽出するのが難しい場面がありますが、awkはフィールドや区切り文字の仕組みを理解していれば、難しい正規表現に頼らずに抽出が可能です。また、数値計算・集計が出来ることで正規表現では出来ないような抽出をこなせるという点も注目したいです。（ただし今回の例では）

## 抽出
ログファイルを見るとき、エラーが発生しているかどうかを気にする場面は非常に多いと思います。
```bash:8-1実行コマンド
cat sample.log | awk /ERROR/
```
grepでいいと思います。多くの環境ではハイライトも効いてくれるので。
```bash:grepで抽出
cat sample.log | grep ERROR
```
強いて言えば、and/or条件などで抽出する際にタイプ数が少なくなる点が魅力でしょうか。あるいは、フィールドを狙い撃ちして抽出出来るのは強いかもしれません。

## grep vs awk : or条件での抽出比較
grep/awkによる抽出について、or条件での例を考えてみます。
12/8にトラブルが発生したという想定で、この日のエラーメッセージを抽出したいとします。

```bash
cat sample.log | grep -e ERROR -e "Dec 8"
cat sample.log | grep -E "ERROR|Dec 8" 
```
```bash
cat sample.log | awk "/ERROR|Dec 8/" 
```

## grep vs awk : and条件での抽出比較
```bash
# 順序を意識しなくて良い方法
cat sample.log | grep ERROR | grep "Dec 8"
cat sample.log | grep -P "(?=.*ERROR)(?=.*Dec 8).*" 
```
```bash
# 順序を意識しなくて良い方法
cat sample.log | awk "/Dec 8/" | awk "/ERROR/" 
```


## フィールド指定
```bash:8-1実行コマンド2
cat sample.log | awk '$3~/ERROR/'
```
正常なメッセージに"ERROR"という文字列がまぎれることはあまりなさそうですし、別にちょっと不要な情報が混じっても大して問題ではないと思いますが（見ることだけが目的の場合…）。



# 実践例9. 同時実行されたプロセスが正しく終了しているかを調べる
```bash:9-実行コマンド
tac hoge.log | awk -F'[][]' '!a[$2]++&&$0=$2$NF'
```

# 実践例10. 実行時間が長いプロセスIDの抽出
アプリケーションのログのなかで、実行時間の長いプロセスを抽出してみます。
PIDが初めて登場した行のタイムスタンプとPIDが最後に登場した行のタイムスタンプの差を取り、大きい順に並べます。

PIDが最初・最後に登場した行のタイムスタンプは、連想配列にPIDをキーとしてそれぞれstart,endという変数名に格納することにします。
PIDが初めて登場したか？については、`!a[$PID]++`でパターンを書けば良さそうです。PIDが最後に登場したというのはどのように判定したら良いでしょうか。実践例9のように** `ひっくり返して!a[$PID]++` ** とする方法を使おうにも、最初に登場したものも一緒に使いたいので厳しそうです。
最後に登場したパターンについては、毎回アクションを実行して、end[PID]=タイムスタンプと格納していくことにします。毎回上書きをするので、自然に各プロセスの最後の行のタイムスタンプ値が入ることになります。


```bash:9-実行コマンド
cat hoge.log | awk -F'[][]' '{"echo "$1"| date -f- +%s" | getline t;end[$2]=t}!a[$2]++{start[$2]=t}END{for(i in a){print i,end[i]-start[i]}}'
```



多分もっと良いコマンド等があると思いますが
