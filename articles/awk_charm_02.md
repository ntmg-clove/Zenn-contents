---
title: "AWKの魅力を伝える: 「階差算出」「集計処理」"
emoji: "✨"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["AWK", "Linuxコマンド"]
published: false
---

# はじめに
以下の記事の続きとなっています。
今回は**集計**をテーマにしていますが、

使用するサンプルデータをこちらにも掲載します。
今回は集計のために疑似の交通費申請フォームを追加して、使用します。

<!-- ::: details クリックして表示 -->
```csv:transport-inputdata-22-1.csv
1,客先,バス,公園前,HOGE駅南口,1,345
1,客先,電車,FUGA線HOGE駅,PIYO駅,1,1234
4,客先,バス,公園前,HOGE駅南口,1,345
4,客先,電車,FUGA線HOGE駅,PIYO駅,1,1234
5,客先,バス,公園前,HOGE駅南口,1,345
5,客先,電車,FUGA線HOGE駅,PIYO駅,1,1234
6,客先,バス,公園前,HOGE駅南口,1,345
6,客先,電車,FUGA線HOGE駅,PIYO駅,1,1234
7,客先,バス,公園前,HOGE駅南口,1,345
7,客先,電車,FUGA線HOGE駅,PIYO駅,1,1234
11,客先,バス,公園前,HOGE駅南口,1,345
11,客先,電車,FUGA線HOGE駅,PIYO駅,1,1234
13,客先,バス,公園前,HOGE駅南口,1,345
13,客先,電車,FUGA線HOGE駅,PIYO駅,1,1234
18,客先,バス,公園前,HOGE駅南口,1,345
18,客先,電車,FUGA線HOGE駅,PIYO駅,1,1234
19,客先,バス,公園前,HOGE駅南口,1,345
19,客先,電車,FUGA線HOGE駅,PIYO駅,1,1234
24,客先,バス,公園前,HOGE駅南口,1,345
24,客先,電車,FUGA線HOGE駅,PIYO駅,1,1234
27,客先,バス,公園前,HOGE駅南口,1,345
27,客先,電車,FUGA線HOGE駅,PIYO駅,1,1234
31,客先,バス,公園前,HOGE駅南口,1,345
31,客先,電車,FUGA線HOGE駅,PIYO駅,1,1234
```
会社に交通費を申請するとき、Web上で入力する作業をスクリプトで自動化しており、その際に使用している独自フォーマットのデータです。[^1]
※駅名、金額などはダミーの値に書き換えています。
[^1]: 本当はこの形式のままアップロードが出来ればいいのですが、弊社ではWeb上で1つ1つ手作業で入力しなければならず、許可を取ってSeleniumによる自動化をさせてもらっています。

よくある形式なので大体わかるかもしれませんが、左から順に
` 日付,目的地,交通機関,発地,着地,片道/往復(1が往復),金額`
となっています。

<!-- ::: -->

# 実践例3. 合計値を取得
awkでは定番であろう代表的な集計処理です。
`transport-inputdata-22-1.csv`を使用します。

## 3-1. 交通費の合計を出力
```bash:3-1 実行コマンド
cat transport-inputdata-22-1.csv | awk -F, '{sum+=$7}END{print sum}'
```
```txt:3-1 実行結果
18948
```

{}のブロックはパターンを省略しているため、毎回実行されます。`$7`の金額の値を変数`sum`に加算して、最後にENDブロックで`sum`の値を出力します。


この例だけだとありきたりなので、もう1つ紹介します。
## 3-2. バスと電車それぞれで合計を出力
```bash:3-2 実行コマンド
cat transport-inputdata-22-1.csv | awk -F, '$3=="バス"{sum_bus+=$7}$3=="電車"{sum_train+=$7}END{print "バス:"sum_bus;print "電車:"sum_train;print "合計:"sum_bus+sum_train}'
```
```txt:3-2 実行結果
バス:4140
電車:14808
合計:18948
```

`$3`の値がバスか電車かで条件分岐して、別々の変数`sum_bus`,`sum_train`に金額を加算し、最後にそれぞれの合計及び合計を出力しています。[^2]
[^2]: この例では条件分岐の種類はバス、電車の2種類のみですが、分岐の項目が多くなってきた場合は実践例5で紹介するような連想配列とfor文を使用する方法も良いと思います。


# 実践例4. 階差を出力する
`openweatherdata.csv`を使用します。気温が3時間前（前の行）からどの程度変化したかを調べて、増分をフィールドとして追加して出力するといったことをやってみます。
また、フィールドが多いので特定のフィールドのみを出力することにします。

```bash:4 実行コマンド
cat openweatherdata.csv | awk -F, -v OFS=, 'NR==1{$9="増分"}NR>1{$9=NR==2?"---":$5-tmp; tmp=$5}{print $1,$2,$3,$5,$9}' | column -s, -t
```
```txt:4 実行結果
日付        時刻      天気    気温   増分
2022-03-05  03:00:00  Clouds  8.21   ---
2022-03-05  06:00:00  Clouds  8.09   -0.12
2022-03-05  09:00:00  Clouds  9.51   1.42
2022-03-05  12:00:00  Clear   13.28  3.77
2022-03-05  15:00:00  Clear   17.62  4.34
2022-03-05  18:00:00  Clear   15.99  -1.63
2022-03-05  21:00:00  Clear   13.77  -2.22
2022-03-06  00:00:00  Clear   9.61   -4.16
2022-03-06  03:00:00  Clouds  7.41   -2.2
2022-03-06  06:00:00  Clouds  7.31   -0.1
2022-03-06  09:00:00  Clouds  9.04   1.73
2022-03-06  12:00:00  Clouds  10.71  1.67
2022-03-06  15:00:00  Clouds  10.88  0.17
2022-03-06  18:00:00  Clouds  8.24   -2.64
2022-03-06  21:00:00  Clouds  7.25   -0.99
2022-03-07  00:00:00  Clear   6.7    -0.55
2022-03-07  03:00:00  Clear   5.89   -0.81
2022-03-07  06:00:00  Clear   5.49   -0.4
2022-03-07  09:00:00  Clouds  7.92   2.43
2022-03-07  12:00:00  Clouds  10.48  2.56
2022-03-07  15:00:00  Clouds  11.74  1.26
2022-03-07  18:00:00  Clouds  9.66   -2.08
2022-03-07  21:00:00  Rain    8.2    -1.46
2022-03-08  00:00:00  Rain    7.56   -0.64
2022-03-08  03:00:00  Rain    5.55   -2.01
2022-03-08  06:00:00  Rain    4.87   -0.68
2022-03-08  09:00:00  Rain    4.76   -0.11
2022-03-08  12:00:00  Clouds  6.36   1.6
2022-03-08  15:00:00  Clouds  9.18   2.82
2022-03-08  18:00:00  Clouds  9.5    0.32
2022-03-08  21:00:00  Clouds  7.75   -1.75
2022-03-09  00:00:00  Clouds  7.33   -0.42
2022-03-09  03:00:00  Clouds  6.47   -0.86
2022-03-09  06:00:00  Clouds  5.98   -0.49
2022-03-09  09:00:00  Clouds  7.6    1.62
2022-03-09  12:00:00  Clouds  9.82   2.22
2022-03-09  15:00:00  Clouds  11.26  1.44
2022-03-09  18:00:00  Clouds  11.11  -0.15
2022-03-09  21:00:00  Clouds  10.35  -0.76
2022-03-10  00:00:00  Clouds  9.6    -0.75
```

## 実行結果の解釈
以下にインデント・注釈を付けました。
```bash
NR==1{
    $9="増分"
}
NR>1{
    $9=NR==2?"---":$5-tmp;
    tmp=$5
}
{
    print $1,$2,$3,$5,$9
}
```

## 3項演算子
人によっては見慣れない表記かと思うので念のため説明をします。
```
$9=NR==2?"---":$5-tmp;
```
この記述法は3項演算子という機能を利用しています。条件分岐を1文で簡潔に記述する方法で、以下のif文による条件分岐のコードと同値になります。
```
if(NR==2){
    $9="---"
}else{
    $9=$5-tmp
}
```
より抽象化すると、以下のようになります。
```
条件式 ? 真である場合の値 : 偽である場合の値
```
C言語やJavaなど多くのプログラミング言語が同様の書式でサポートしています。
タイプ数が少なくなるのが魅力で、この程度シンプルな処理ならともかく、
ネストをしたり条件や値などが長くなったり複雑になるようなものは可読性を落とすことから、プログラム中で積極的に使用されることはない印象です。
個人的にはワンライナーは極力タイプ数を減らしたいので、awk内では積極的に使うようにしています。

# 実践例5: 平均値を出力
`openweatherdata.csv`から、日付毎の平均気温を出力します。
ここでは、このシリーズ初の`for文`が登場します。

```bash:5 実行コマンド
cat openweatherdata.csv | awk -F, 'NR>1{cnt[$1]++;sum[$1]+=$5}END{for(i in cnt){print i,sum[i]/cnt[i]}}' | sort
```
```txt:5 実行結果
2022-03-05 12.3529
2022-03-06 8.80625
2022-03-07 8.26
2022-03-08 6.94125
2022-03-09 8.74
2022-03-10 9.6
```

## 実行結果の解釈
以下にインデント・注釈を付けました。
```bash:awkコード
# 最初（NR:1）はヘッダなので無視。
NR>1{
    # 平均を出すために個数が必要なのでcntに日付をキーとして+1する
    cnt[$1]++;
    # 天気の情報を日付をキーとしてsumに加算。
    sum[$1]+=$5
}

# 出力はENDブロックでまとめて行う
END{
    # 範囲for文で日付を取り出し、日付と 平均（=合計/個数） を出力する
    for(i in cnt){
        print i,sum[i]/cnt[i]
    }
}
```

このように、特定のフィールドをキーとして連想配列に保持しておき、ENDブロックでfor文を利用して取り出すといったテクニックは頻繁に利用する気がします。連想配列を上手く利用することで、SQLなどで言うところの`group by`に近いような動作も可能です。
awkのコードはC言語などのプログラミングに慣れている人であればすぐに理解できるものだと思います。

しかし、awkを始め連想配列は順序を保持しない場合が多く、今回は日付順にするために最後に`| sort`を入れています。
ヘッダが欲しい場合は以下のようにBEGINブロックに記述するとスリムになると思います。
```bash:ヘッダ出力
BEGIN{print "日付","平均気温"}
```


# まとめと次回予告
今回は集計処理をメインに紹介しました。

次回は、awkならではの**集計処理**などの観点で執筆したいと思います。
